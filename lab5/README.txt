Vishal Damojipurapu
vdamojip@ucsc.edu
LAB 5: DECIMAL TO BINARY CONVERTER
2/28/18
1D, Carlos Ramirez

Magic Numbers:
1. 0b1010
2. 0x0745
3. 0123 (octal)

	Unlike the other lab, I learned so many different aspects of MIPS in this lab. The most important tool I learned was debugging. This was a huge skill to learn because when my output was incorrect, I was able to step through line by line and see how the values of each register was changing. I also now fully understand the concept of branching, and how it is very similar to goto statements in java. On top of that, I learned the different kinds of branches. Moreover, I was surprised at how we had to take in the program input, instead of using syscall operators. This was very difficult for me at first because I was not sure how to start. Luckily, the lab TA was very helpful and gave us useful pseudocode on how to start taking in the program argument. The difficult part for me was understanding why we had to multiply the value of our input. I ended up asking the TA why and he told me it was because we had to shift over a place when adding in the next number. On the other hand, converting the decimal number worked really well for me because I have a good understanding of it. Printing out the binary representation really worked well for me as well because I was able to get it on my first try, which actually surprised me. Storing the decimal number in $s0 also was a little tricky for me, but in the end all I did was move my decimal number back into the $s0 register because it was part of the lab description to have the number stored in $s0 by the end of the program. For moving the decimal value back into the $s0 register, I discussed that part with my friend Shridhik John, who said it should be fine as long as $s0 contains the actual number by the end of the program. Thus, I moved my number back into $s0 in the exit branch, which is the end of the program. The rest of the help I received came from only my lab TA, who was really helpful in helping me start my program.
	When I input a number that is too large to fit in a 32-bit two's complement number, the number cuts off and becomes a negative number. For example, when I input the maximum number, 2^31 - 1, the output is a 0 followed by 31 1's. But, when I input 2^31, the input changes to -2^31 and the output printed is a 1 followed by 31 0's. Technically, the largest number that can be inputted is 2^31 - 1, so when we input a number greater than that, the number cuts off, wraps around, and becomes a negative number. 
	When I input a number that is too small (a negative number), then I get an arithmetic overflow because the maximum negative number I can input is 2^31 - 1. When I input that number, I get a 1 followed by 30 0's and ending with a single 1. This is correct because this is the binary representation of -2^31 - 1. Anything smaller than that number results in overflow and my program execution terminating with errors.
	The difference between mult and multu is that mult involves multiplying two numbers, while multu multiplies two unsigned numbers. Thus, multu does not involve negative numbers. According to a piazza post I saw earlier, the two different operators store their values in different registers as well. In my program, I used neither of those. Instead, I used mulu, which I know simplifies into multu and mflo from checking the text segment box in MARS. In that case, I technically used multu, and this was because I knew the byte I was manipulating was unsigned because I just focusing on the actual number itself and not the negative sign. I did not have to deal with signed numbers until the twos complement portion of the program, which was later on. 
	A binary to decimal converter would be very similar to our decimal to binary converter because it is simply the opposite of our program. A majority of the program would look the same, such as loading in the byte, printing out the decimal number, checking to see if the inputted number is negative, and printing out the decimal number accordingly. However, I learned from the TA that there is one particular difference and that has to do with the multiplying part in the beginning. In our code we multiplied by 10 because we wanted to shift over a place in base 10, so for a binary to decimal converter we would do something similar. In this case, we would multiply by 2 to shift over a place. 